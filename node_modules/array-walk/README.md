# array-walk
Walk arrays like a boss

## Installation
```
# Yep, it's that simple
npm i --save array-walk
```

## Usage

#### .chop(size, array) - CUT MY LIFE INTO PIECES!
```javascript
const array = require('array-walk');

let test = [1,2,3,4,5,6,7,8,9];
let pieces = array.chop(3, test) // Chop pieces with size 3 from array "test"
/* Result: [[1,2,3], [4,5,6], [7,8,9]]*/
```

#### .map(array, iteratee, callback) - Call a function on every item
Walks your array and calls `iteratee(currentItem, next)` on every item.

You **need** to call `next()` in your `iteratee` or the loop won't continue to the next item.

After all items are processed, the `callback()` is called (no arguments).

Pure synctastic awesomeness!
 
```javascript
const array = require('array-walk');

let test = [1,2,3,4,5,6,7,8,9];

array.map(test, (item, next) => {
  console.log(`The current item is ${item}!`);
  next(); //Proceed to next item
}, () => {
  // Callback that is called after all items are walked
  console.log('Done! :)')
});
```

#### .splay(count, array, iteratee, callback) - Works like .map() but in parallel
`.splay()` walks your array with `count` pseudo-threads.

Every "Thread" has it's own queue with the items it will process.

After all Threads finish their work, a final callback will be executed.

```javascript
let fs = require('fs');
let array = require('array-walk');

let test = [...BIG ARRAY WITH 100000 ITEMS...];

/*
This Example checks if the current item exists 
as a file with a maximum of 25 operations at a time
*/
array.splay(25, test, (item, next) => {
  fs.exists(item, (exists) => {
    console.log(exists ? `WOO! ${item} exists!` : `Nope. No ${item} here`);
    next();
  });
}, () => {
  console.log('All done!');
});
```

#### Do you like it?
If so, I'd be **very** happy if you tell your friends about this project or star the repo :)
