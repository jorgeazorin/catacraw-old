"use strict";
const os = require('os');
const Parallel = require('paralleljs');

/**
 * Generate a UID
 * Used only by .splay()
 *
 * @returns {string}
 */
function mkuid() {
    var d = new Date().getTime();
    return 'xxxxxxxxyyyxxxyxxxxxxxxxxyxxxx'.replace(/[xy]/g, function (c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

/**
 * Array-Walk "Class"
 * @type {{map: ARRAY.map, chop: ARRAY.chop, splay: ARRAY.splay, __join__: ARRAY.__join__, __joining_threads__: {}}}
 */
const ARRAY = {
    /**
     * Chop an array into smaller parts
     *
     * e.g:  [1,2,3,4,5,6] => array.chop(arr, 3) => [[1,2,3], [4,5,6]]
     * @param array The array to chop
     * @param size How big you want your chops
     * @returns {Array}
     */
    chop: function (array, size) {
        let arr = [];

        for (let i = 0; i < array.length; i++) {
            arr[arr.length] = array.slice(i, i + size);
            i += (size - 1);
        }

        return arr;
    },

    /**
     * Map a function to every item in an array
     * Note that $func gets the current item AND a completion callback as parameters.
     * map() will wait until the completion callback was called before calling the next iteratee.
     *
     * @param array The array to walk over
     * @param iteratee The function to call on every item.
     * @param callback The callback to call after finishing
     * @param index DO NOT PASS THIS PARAMETER. It's used internally to keep track of $array.
     */
    map: function (array, iteratee, callback, index) {
        if (typeof index === typeof undefined) index = 0;
        if (index < array.length) {
            iteratee(array[index], function () {
                ARRAY.map(array, iteratee, callback, ++index);
            });
        } else {
            callback();
        }
    },

    /**
     * Walk a big array with multiple sync pseudo-threads
     * splayLimit defines how many items can be processed at a time
     *
     * @param splayLimit
     * @param array
     * @param iteratee
     * @param callback
     */
    splay: function (splayLimit, array, iteratee, callback) {
        const SPLAY_ID = mkuid();

        if (splayLimit >= array.length) {
            ARRAY.map(array, iteratee, callback);
        } else {
            let chops = ARRAY.chop(array, splayLimit);

            for (let i = 0; i < chops.length; i++) {
                process.nextTick(function () {
                    ARRAY.map(chops[i], iteratee, function () {
                        ARRAY.__join__(i, chops.length, SPLAY_ID, callback);
                    });
                });
            }
        }
    },

    /**
     * Works like .splay() but with one process per cpu-core
     * Scales automagically. Totally awesome (but unstable)!
     *
     * @param array The array to walk
     * @param iteratee The function to apply to each element
     * @param callback A final callback
     */
    nsplay: function (array, iteratee, callback) {
        process.nextTick(function () {
            let parallel = new Parallel(array, {
                maxWorkers: os.cpus().length
            });

            parallel.map(iteratee).then(callback);
        });
    },

    /**
     * Joins splayed threads back together for a final callback
     * You *could* call this manually, but you'd need to know the splayID.
     *
     * @param index The id of the thread that wants to join
     * @param splayCount How many threads we need to join before a callback is allowed
     * @param splayID The UID of this splay operation
     * @param callback The callback to call after all threads have joined
     * @private
     */
    __join__: function (index, splayCount, splayID, callback) {
        // Check if this splayID is already tracked
        // If not track it
        if (typeof ARRAY.__joining_threads__[splayID] === typeof undefined) {
            ARRAY.__joining_threads__[splayID] = {};
        }

        // Check if the index is tracked.
        // If not track it
        if (typeof ARRAY.__joining_threads__[splayID][`#${index}`] === typeof undefined) {
            ARRAY.__joining_threads__[splayID][`#${index}`] = true;
        }

        // Check if all threads have joined and call the callback
        if (ARRAY.__joining_threads__[splayID].length === splayCount) {
            callback();
        }
    },

    /**
     * A simple object used by __join__() to store it's data
     *
     * DON'T EVER DARE TO MODIFY THIS.
     * array-walk might kill your cat otherwise.
     */
    __joining_threads__: {}
};

module.exports = ARRAY;
