"use strict";
const ProxiesEmptyException = require('./exceptions/ProxiesEmptyException.js');
const request = require('request').defaults({
    timeout: 5000
});
const progress = require('progress');
const array = require('array-walk');
const async = require('async');
const chalk = require('chalk');
const http = require('http');
const fs = require('fs');
const Q = require('q');

var AutoProxy = {
    /**
     * Create a new instance
     *
     * Usage:
     * require('auto-proxy')
     *      .new()
     *      .then((proxy) => {
     *          proxy.doStuff();
     *      });
     *
     * @param interval How many a times a proxy can be used before it is swapped automagically
     * @param config An object that overrides AutoProxy.config
     * @param localList
     * @param disableCrawling
     * @returns Promise
     */
    new: function (interval, config, localList, disableCrawling) {
        // Promise
        let defer = Q.defer();

        // Default Settings
        AutoProxy.proxyList = [];
        AutoProxy.proxyCache = [];
        AutoProxy.blockedProxies = [];
        AutoProxy.usageCounter = 0;
        AutoProxy.usageLimit = interval;
        AutoProxy.config = {
            enableLogging: false,
            autoRefresh: false,
            reLoop: false
        };

        // Update settings
        for (let key in config) {
            if (key === '__simple__') {
                AutoProxy.__simple__.__config__ = config[key];
            } else {
                AutoProxy.config[key] = config[key];
            }
        }

        // Set logger
        AutoProxy.log = AutoProxy.config.enableLogging ? AutoProxy.logger : AutoProxy.noop;

        if (disableCrawling === true) {
            AutoProxy.loadProxyFile(localList);
            AutoProxy.testProxies().then(function () {
                defer.resolve(AutoProxy);
            });
        } else {
            AutoProxy.refillProxies(true).then(function () {
                AutoProxy.loadProxyFile(localList);
                AutoProxy.testProxies().then(function () {
                    defer.resolve(AutoProxy);
                });
            });
        }

        // Promise to be ready soon
        return defer.promise;
    },

    /**
     * Load a local proxy file
     * @param localList
     */
    loadProxyFile: function (localList) {
        if (typeof localList === typeof "") {
            AutoProxy.log("Checking if passed proxyfile is accessible...");
            try {
                fs.accessSync(localList, fs.F_OK);

                AutoProxy.log("Reading proxies from file...");

                fs.readFileSync(localList).toString().split('\n').forEach((line) => {
                    AutoProxy.proxyList.push(line);
                });
            } catch (e) {
                AutoProxy.log("Skipping proxyfile because node cannot access it!");
                AutoProxy.log(require("util").inspect(e));
            }
        }
    },

    /**
     * Tell AutoProxy to refill the proxy array
     * @param firstExecution Wether this was called from .new() or not
     * @returns Promise
     */
    refillProxies: function (firstExecution) {
        let defer = Q.defer();

        AutoProxy.log('Refilling proxies...');
        if (firstExecution === true) {
            AutoProxy.crawl().then(function () {
                if (AutoProxy.config.reLoop === true) {
                    AutoProxy.proxyCache = AutoProxy.proxyList;
                }

                defer.resolve();
            });
        } else {
            if (AutoProxy.config.reLoop === true) {
                AutoProxy.log("Re-Loop is enabled. Resetting proxies...");
                AutoProxy.proxyList = AutoProxy.proxyCache;
                defer.resolve();
            } else if (AutoProxy.config.autoRefresh === true) {
                AutoProxy.log("Auto-Refresh is enabled. Trying to get new proxies...");
                AutoProxy.crawl().then(function () {
                    defer.resolve();
                });
            } else {
                defer.reject(new ProxiesEmptyException());
            }
        }

        return defer.promise;
    },

    /**
     * Downloads new proxies and checks if they are online
     *
     * @returns {*|promise}
     */
    crawl: function () {
        let defer = Q.defer();

        AutoProxy.log("Loading scrapers...");
        let list = AutoProxy.proxyList;

        const scrapers = [
            require('./scrapers/proxy-listen.de.js'),
            require('./scrapers/free-proxy-list.net.js'),
            require('./scrapers/nordvpn.com.js')
            //require('./scrapers/freeproxylists.com')
        ];

        array.map(scrapers, function (scraper, next) {
            scraper(AutoProxy.log).then(function (proxies) {
                list = AutoProxy.arrayUniq(list.concat(proxies));
                next();
            });
        }, function () {
            AutoProxy.proxyList = list;

            AutoProxy.log("Scraping done!");
            AutoProxy.log(`Found ${AutoProxy.proxyList.length} Proxies!`);
            AutoProxy.testProxies().then(function () {
                defer.resolve();
            });
        });

        return defer.promise;
    },

    /**
     * Test all proxies by poking google.com
     * @returns {*|promise}
     */
    testProxies: function () {
        let defer = Q.defer();

        AutoProxy.log('Testing proxies by poking goo.gl');

        let pb;

        if (AutoProxy.config.enableLogging) {
            pb = new progress(':percent :bar [:current of :total] [ON: :on] [ETA: :eta] [Current: :proxy] [:error]', {
                total: AutoProxy.proxyList.length,
                clear: false,
                width: 50
            });
        }

        let onlineCounter = 0;
        async.mapLimit(AutoProxy.proxyList, 250, function (item, callback) {
            try {
                if (item.split(':')[1] >= 0 && item.split(':')[1] <= 65535) {
                    request.get('http://goo.gl/', {
                        proxy: `http://${item}`
                    }, function (err, res) {
                        if (AutoProxy.config.enableLogging) {
                            //noinspection JSUnresolvedFunction
                            pb.tick({
                                proxy: item,
                                error: err != null ? chalk.red(err['code']) : chalk.green('SUCCESS'),
                                on: onlineCounter
                            });
                        }

                        if (typeof err === typeof undefined || err === null) {
                            onlineCounter++;
                            callback(null, item);
                        } else {
                            callback(null, null);
                        }
                    });
                } else {
                    pb.tick({
                        proxy: item,
                        error: chalk.red("PORT_RANGE_ERR"),
                        on: onlineCounter
                    });

                    callback(null, null);
                }
            } catch (e) {
                console.error(e['code']);
            }
        }, function (err, res) {
            let tmp = [];

            for (let i = 0; i < res.length; i++) {
                if (res[i] !== null) {
                    tmp.push(res[i]);
                }
            }

            AutoProxy.proxyList = tmp;
            AutoProxy.log(`After checking there are ${tmp.length} proxies left`);

            defer.resolve();
        });

        return defer.promise;
    },

    /**
     * Forces AutoProxy to switch to a new proxy before the usage counter is full
     * Resets the counter to 0
     *
     * @returns {*|promise}
     */
    forceNext: function () {
        let defer = Q.defer();

        if (AutoProxy.proxyList.length > 1) {
            AutoProxy.proxyList.splice(0, 1);
            AutoProxy.usageCounter = 0;
            defer.resolve();
        } else {
            AutoProxy.log("No more cached proxies!");
            if (AutoProxy.config.autoRefresh === true || AutoProxy.config.reLoop === true) {
                AutoProxy.refillProxies().then(function () {
                    defer.resolve();
                });
            } else {
                AutoProxy.log("Re-Loop and Auto-Refresh are disabled!");
                defer.reject(new ProxiesEmptyException());
            }
        }

        return defer.promise;
    },

    /**
     * Marks the current proxy as "blocked" and switches to a new one
     * @returns {Promise}
     */
    blockCurrent: function () {
        let defer = Q.defer();

        AutoProxy.blockedProxies.push(AutoProxy.proxyList[0]);
        AutoProxy.forceNext().then(function () {
            defer.resolve();
        });

        return defer.promise;
    },

    /**
     * Gets the current proxy (ip-only)
     * @param ignoreUsage Wether to count this access or not
     * @returns {*}
     */
    getCurrent: function (ignoreUsage) {
        let defer = Q.defer();

        if (ignoreUsage !== true) {
            AutoProxy.usageCounter++;
        }

        if (AutoProxy.usageCounter >= AutoProxy.usageLimit) {
            AutoProxy.usageCounter = 0;
            AutoProxy.forceNext().then(function () {
                defer.resolve(AutoProxy.proxyList[0]);
            });
        }

        AutoProxy.log(`Proxy ${AutoProxy.proxyList[0]} was used. [Usage ${AutoProxy.usageCounter} of ${AutoProxy.usageLimit}]`);
        defer.resolve(AutoProxy.proxyList[0]);

        return defer.promise;
    },

    /**
     * Works like getCurrent() but prefixes the IP with "http://"
     *
     * @see getCurrent()
     * @param ignoreUsage
     * @returns {Promise}
     */
    getPrefixedCurrent: function (ignoreUsage) {
        let defer = Q.defer();

        AutoProxy.getCurrent(ignoreUsage).then(function (ip) {
            defer.resolve(ip);
        });

        return defer.promise;
    },

    /**
     * The logger. Simple but effective
     *
     * @param msg
     */
    logger: function (msg) {
        console.log(`[AutoProxy] ${msg}`);
    },

    /**
     * Remove duplicate items from $array and return a new cleaned one
     * We should probably move this method somewhere else...
     *
     * @param array
     * @returns {string|Buffer|Array.<T>}
     */
    arrayUniq: function (array) {
        let a = array.concat();
        for (let i = 0; i < a.length; ++i) {
            for (let j = i + 1; j < a.length; ++j) {
                if (a[i] === a[j]) {
                    a.splice(j--, 1);
                }
            }
        }

        return a;
    },

    /**
     * Literally does nothing. EVER.
     */
    noop: function () {

    },

    /**
     * The __simple__ API provides the most common methods as sync versions.
     * However it does *not* support autoRefreshing and reLoops by design.
     *
     * __simple__ might come in handy where you need a way to access
     * the proxies whithout starting hundrets of promises (e.g. a loop)
     *
     * If you need to get new proxies, you should tell AutoProxy to get them.
     * After that call __simple__.refresh() to transfer the proxyList into cache.
     *
     * Example:
     * AutoProxy.refillProxies().then(() => {
     *   AutoProxy.__simple__.refresh();
     * });
     *
     * If you need to disable reLooping you can set __simple__.__config__.reLoop to false
     * Note that in this case AutoProxy will throw a ProxiesEmptyException
     * when it is told to leave the cache's bounds.
     *
     */
    __simple__: {
        __storage__: [],
        __cache__: [],
        __blocked__: [],
        __usageCounter__: 0,
        __config__: {
            reLoop: true
        },

        __isBlocked: function (ip) {
            for (let key in AutoProxy.__simple__.__blocked__) {
                if (AutoProxy.__simple__.__blocked__[key] === ip) {
                    return true;
                    break;
                }
            }

            return false;
        },

        /**
         * Convenience method to init the simple-cache
         */
        init: function () {
            AutoProxy.__simple__.refresh();
        },

        /**
         * Refill the storage from proxyList
         */
        refresh: function () {
            AutoProxy.__simple__.__storage__ = AutoProxy.proxyList;
            AutoProxy.__simple__.resetCache();
        },

        /**
         * Refill the cache from storage
         */
        resetCache: function () {
            AutoProxy.__simple__.__cache__ = AutoProxy.__simple__.__storage__;
            AutoProxy.__simple__.__blocked__ = [];
        },

        next: function () {
            if (AutoProxy.__simple__.__cache__.length == 1) {
                if (AutoProxy.__simple__.__config__.reLoop) {
                    AutoProxy.__simple__.resetCache();
                } else {
                    throw new ProxiesEmptyException("AutoProxy.__simple__ was told to stop reLooping. \n However no one called .refresh() or .resetCache() so we hit the cache's bounds. \n That raised a ProxiesEmptyException. \n Please check if you refill the cache correctly or enable reLooping!");
                }
            } else {
                AutoProxy.__simple__.__cache__.splice(0, 1);
                AutoProxy.__simple__.__usageCounter__ = 0;
            }
        },

        /**
         * Get a proxy (respecting usage limits)
         * @returns {*}
         */
        get: function () {
            // Check if this is the first run
            if (
                AutoProxy.__simple__.__storage__.length === 0 &&
                AutoProxy.__simple__.__cache__.length === 0
            ) {
                AutoProxy.__simple__.refresh();
            }

            // Respect the config limits!
            AutoProxy.__simple__.__usageCounter__++;
            if (AutoProxy.__simple__.__usageCounter__ > AutoProxy.config.usageLimit) {
                AutoProxy.__simple__.next();
            }

            while (AutoProxy.__simple__.__isBlocked(AutoProxy.__simple__.__cache__[0])) {
                AutoProxy.__simple__.next();
                AutoProxy.__simple__.__usageCounter__ = 0;
            }

            // Get the proxy
            return AutoProxy.__simple__.__cache__[0];
        },

        block: function () {
            AutoProxy.__simple__.__blocked__.push(AutoProxy.__simple__.__cache__[0]);
            AutoProxy.__simple__.next();
        }
    }
};

module.exports = AutoProxy;
